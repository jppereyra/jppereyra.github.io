<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://juanpereyra.com/ name=base><title>
            
                Recursion is Hard
            
        </title><meta content="Recursion is Hard" property=og:title><meta content="Personal website." property=og:description><meta content="Personal website." name=description><link href=https://juanpereyra.com/icons/favicon/favicon.svg rel=icon type=image/png><link href=https://juanpereyra.com/fonts.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=/syntax-theme-dark.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=/syntax-theme-light.css rel=stylesheet><script defer src=https://juanpereyra.com/js/codeblock.js></script><script defer src=https://juanpereyra.com/js/toc.js></script><script src=https://juanpereyra.com/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="
    Juan P. Pereyra
" href=https://juanpereyra.com/atom.xml rel=alternate type=application/atom+xml><link href=https://juanpereyra.com/theme/light.css rel=stylesheet><link href=https://juanpereyra.com/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://juanpereyra.com/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://juanpereyra.com/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://juanpereyra.com/>Juan P. Pereyra</a><div class=socials></div></div><div class=right-nav><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://juanpereyra.com/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://juanpereyra.com/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Recursion is Hard</div><div class=meta>Posted on <time>2025-09-22</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://juanpereyra.com/tags/learn-to-code/>learn to code</a> </span></div></div><section class=body><p><strong>ðŸ›‘ Spoilers Ahead</strong>: This topic doesn't appear on the Techtonica curriculum until <a href=https://github.com/Techtonica/curriculum/blob/main/README.md#week-7---Advanced-JS-and-React>week 7</a>. It is only mentioned on this post because someone said to me <em>"recursion is hard"</em>. So, if you know what recursion is and also think it's hard, read on, otherwise you might want to wait until the topic is formally introduced.<p>If you're still with me, let's see... what's up with this recursion thing:<pre class="language-javascript z-code" data-lang=javascript><code class=language-javascript data-lang=javascript><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-storage z-type z-function z-ts">function</span> <span class="z-meta z-definition z-function z-ts"><span class="z-entity z-name z-function z-ts">factorial</span></span><span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">n</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>  
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts">  <span class="z-keyword z-control z-conditional z-ts">if</span> <span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">n</span> <span class="z-keyword z-operator z-comparison z-ts">===</span> <span class="z-constant z-numeric z-decimal z-ts">0</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-constant z-numeric z-decimal z-ts">1</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> base case</span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts">  <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-variable z-other z-readwrite z-ts">n</span> <span class="z-keyword z-operator z-arithmetic z-ts">*</span> <span class="z-meta z-function-call z-ts"><span class="z-entity z-name z-function z-ts">factorial</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">n</span> <span class="z-keyword z-operator z-arithmetic z-ts">-</span> <span class="z-constant z-numeric z-decimal z-ts">1</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">}</span></span></span>
</span></code></pre><p>One defines a base case, a recursive step, and done! Easy enough, right? Not quite, I think. Recursion is often taught as an alternative to looping in the context of an <a href=https://en.wikipedia.org/wiki/Imperative_programming>imperative programming</a> language as a way to simplify the code. Let's see what the <code>factorial()</code> function looks like written in a more imperative way:<pre class="language-javascript z-code" data-lang=javascript><code class=language-javascript data-lang=javascript><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-storage z-type z-function z-ts">function</span> <span class="z-meta z-definition z-function z-ts"><span class="z-entity z-name z-function z-ts">factorial</span></span><span class="z-meta z-parameters z-ts"><span class="z-punctuation z-definition z-parameters z-begin z-ts">(</span><span class="z-variable z-parameter z-ts">n</span><span class="z-punctuation z-definition z-parameters z-end z-ts">)</span></span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts">  <span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">let</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-readwrite z-ts">result</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-constant z-numeric z-decimal z-ts">1</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts">  <span class="z-keyword z-control z-loop z-ts">for</span> <span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-var z-expr z-ts"><span class="z-storage z-type z-ts">let</span> <span class="z-meta z-var-single-variable z-expr z-ts"><span class="z-meta z-definition z-variable z-ts"><span class="z-variable z-other z-readwrite z-ts">i</span></span> </span><span class="z-keyword z-operator z-assignment z-ts">=</span> <span class="z-constant z-numeric z-decimal z-ts">1</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-variable z-other z-readwrite z-ts">i</span> <span class="z-keyword z-operator z-relational z-ts">&lt;=</span> <span class="z-variable z-other z-readwrite z-ts">n</span><span class="z-punctuation z-terminator z-statement z-ts">;</span> <span class="z-variable z-other z-readwrite z-ts">i</span><span class="z-keyword z-operator z-increment z-ts">++</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span>
</span></span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts"><span class="z-meta z-block z-ts">    <span class="z-variable z-other z-readwrite z-ts">result</span> <span class="z-keyword z-operator z-assignment z-compound z-ts">*=</span> <span class="z-variable z-other z-readwrite z-ts">i</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts"><span class="z-meta z-block z-ts">  <span class="z-punctuation z-definition z-block z-ts">}</span></span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts">  <span class="z-keyword z-control z-flow z-ts">return</span> <span class="z-variable z-other z-readwrite z-ts">result</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></span></span><span class="z-source z-ts"><span class="z-meta z-function z-ts"><span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">}</span></span></span>
</span></code></pre><p>So, it's not much worse in terms of style and if you're already comfortable with <code>for</code> loops and variables, it may feel much more comfortable. So, if you are still curious about recursion, let me tell you the story of recursion the way I learned it when I was in college...<p><em><strong>Disclaimer</strong> Please note that in the preceding examples, in an effort to keep the code simple, I omitted checking the function's input parameters. In your code you should check your input params, in this case you could have used something like:</em><pre class="language-javascript z-code" data-lang=javascript><code class=language-javascript data-lang=javascript><span class="z-source z-ts"><span class="z-keyword z-control z-conditional z-ts">if</span> <span class="z-meta z-brace z-round z-ts">(</span><span class="z-keyword z-operator z-logical z-ts">!</span><span class="z-meta z-function-call z-ts"><span class="z-support z-class z-builtin z-ts">Number</span><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">isInteger</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-variable z-other z-readwrite z-ts">n</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-keyword z-operator z-logical z-ts">||</span> <span class="z-variable z-other z-readwrite z-ts">n</span> <span class="z-keyword z-operator z-relational z-ts">&lt;</span> <span class="z-constant z-numeric z-decimal z-ts">0</span><span class="z-meta z-brace z-round z-ts">)</span> <span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">{</span> <span class="z-comment z-line z-double-slash z-ts"><span class="z-punctuation z-definition z-comment z-ts">//</span></span><span class="z-comment z-line z-double-slash z-ts"> </span>
</span></span><span class="z-source z-ts"><span class="z-meta z-block z-ts">    <span class="z-keyword z-control z-trycatch z-ts">throw</span> <span class="z-new z-expr z-ts"><span class="z-keyword z-operator z-new z-ts">new</span> <span class="z-entity z-name z-type z-ts">Error</span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-string z-quoted z-single z-ts"><span class="z-punctuation z-definition z-string z-begin z-ts">'</span>Invalid argument: "n" must be a non-negative integer.<span class="z-punctuation z-definition z-string z-end z-ts">'</span></span><span class="z-meta z-brace z-round z-ts">)</span></span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></span><span class="z-source z-ts"><span class="z-meta z-block z-ts"><span class="z-punctuation z-definition z-block z-ts">}</span></span>
</span></code></pre><p>Ok, on with the storytelling: in a land far, far away... in a forgotten time (?) there was a programming language known as Haskell.<p>Haskell did not have loops of any kind, nor it had any variables (in the traditional sense) or instructions/statements. But, you say, how are you supposed to program without loops, variables and instructions?? (I can hear the outrage).<p>The answer is: functions. Haskell gives you:<ul><li>Functions.<li>Constants (immutable variables, i.e. once you do <code>x = 5</code>, you can't assign <code>x</code> any other value).<li>A few other things we're not going to get into here.</ul><p>So, if all you have are functions, then recursion all of the sudden becomes your best friend! Let's look at <code>factorial()</code> in Haskell. The syntax will look a bit weird, but worry not, it's actually pretty easy to understand:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">factorial</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">Integer</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Integer</span>
</span></span><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"></span>factorial <span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>
</span><span class="z-source z-haskell">factorial n <span class="z-keyword z-operator z-haskell">=</span> n * factorial (n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>)
</span></code></pre><p>The way to read this in plain English is:<p>Line 1: <em>"There is a function <code>factorial</code> which takes an <code>Integer</code> as its only parameter and returns another <code>Integer</code>"</em>. Line 2: <em>"When <code>factorial 0</code> gets called somewhere, return 1"</em>. Line 3: <em>"When <code>factorial n</code> gets called, take <code>n</code>, multiply it by the result of <code>factorial(n-1)</code> and return that."</em><p>If you think this is more similar to a mathematical definition than a computer program, you are correct! Haskell is what is known as a <a href=https://en.wikipedia.org/wiki/Declarative_programming>declarative programming</a> language (and, in particular, a <a href=https://en.wikipedia.org/wiki/Functional_programming>functional programming</a> language) . In this world you describe the relationships between the operations and <em>not the control flow</em>. The language itself will figure out how to produce the desired result.<p>You may still be wondering <strong>how</strong> this detour into the declarative programming rabbit hole will help you understand recursion better. In my humble opinion, for recursion to make sense you have to forget that you are in the imperative paradigm and imagine you are in the declarative realm, where all operations are defined <em>as functions</em> of other operations.<p>In every recursive function you need a <em>base case</em>, which is the basic fact or state from which all other cases can be derived, and we usually write that first, probably to avoid forgetting about it (we forget, we get infinite recursion and bad things happen).<p>This type of programming generally shines when dealing with repetitive patterns or structures, for example lists and trees.<p>Recursion has all sorts of problems when used in imperative languages, but it is usually taught that way because of their popularity, and because people don't have the time to learn an entirely new programming language.<p>However, many popular programming languages are a confused mess of features (ahem, JavaScript...) taken from other languages, for example:<pre class="language-javascript z-code" data-lang=javascript><code class=language-javascript data-lang=javascript><span class="z-source z-ts"><span class="z-meta z-array z-literal z-ts"><span class="z-meta z-brace z-square z-ts">[</span><span class="z-constant z-numeric z-decimal z-ts">1</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-constant z-numeric z-decimal z-ts">2</span><span class="z-punctuation z-separator z-comma z-ts">,</span> <span class="z-constant z-numeric z-decimal z-ts">3</span><span class="z-meta z-brace z-square z-ts">]</span></span><span class="z-meta z-function-call z-ts"><span class="z-punctuation z-accessor z-ts">.</span><span class="z-entity z-name z-function z-ts">map</span></span><span class="z-meta z-brace z-round z-ts">(</span><span class="z-meta z-arrow z-ts"><span class="z-variable z-parameter z-ts">x</span> </span><span class="z-meta z-arrow z-ts"><span class="z-storage z-type z-function z-arrow z-ts">=></span> </span><span class="z-variable z-other z-readwrite z-ts">x</span> <span class="z-keyword z-operator z-arithmetic z-ts">*</span> <span class="z-constant z-numeric z-decimal z-ts">2</span><span class="z-meta z-brace z-round z-ts">)</span><span class="z-punctuation z-terminator z-statement z-ts">;</span>
</span></code></pre><p>written in Haskell...<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell">map (<span class="z-keyword z-operator z-haskell">\</span>x <span class="z-keyword z-operator z-haskell">-></span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span> * x) [<span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">3</span>]
</span></code></pre><p>See any similarities?<p>In fact, I believe a good chunk of the success of JavaScript is due to their adoption of functional programming features, but I digress.<p>To come back to my earlier point, learning about recursion using an imperative language feels like doing it the hard way, and even though it may be quicker in the short term, the long-term learning suffers. After spending some time with a purely functional language like Haskell you begin to internalize that, in writing code this way, you are describing the behavior of data structures in a very elegant way, but letting go of the illusion of control provided by <code>for</code>s, <code>if</code>s, etc. can be really hard at the beginning.<p>I will leave this topic here for now, and maybe pick it back up if folks are interested in it. There is also a fascinating rabbit hole to explore in how recursion works under the hood and it's effects on memory management.<p>Making a choice between imperative and declarative programming, is also a choice of coding style and specifically of code structure, which leads us to the next topic...</section></article></main></div></div><div class=right-content></div>